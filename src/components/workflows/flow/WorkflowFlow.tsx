'use client';

import React, { useCallback, useEffect, useMemo, useState, useRef } from 'react';
// Import our custom CSS module first
import styles from './ReactFlow.module.css';
// Import React Flow and its components
import ReactFlow, {
  ReactFlowProvider, 
  useNodesState, 
  useEdgesState,
  useReactFlow,
  Controls,
  Background,
  BackgroundVariant,
  Edge,
  Node,
  NodeMouseHandler,
  ConnectionLineType,
  MarkerType,
  EdgeProps, // Import EdgeProps
  OnConnectStartParams, // Import OnConnectStartParams
  Connection, // Import Connection type for onConnect
  addEdge, // Import addEdge helper
} from 'reactflow';
// Import React Flow CSS here, after our module
import 'reactflow/dist/style.css';

import { WorkflowStep } from '@/types/workflow';
import { stepsToNodesAndEdges } from './utils/flowTransformers';
import { nodeTypes } from './nodes';
import { edgeTypes } from './edges';

interface WorkflowFlowProps {
  steps: WorkflowStep[];
  onStepEdit: (index: number) => void;
  onStepDelete: (index: number) => void;
  // Updated prop for adding steps via "+" button click
  onAddStepClick: (sourceNodeId: string, sourceHandleId?: string) => void; // Add sourceHandleId
  className?: string;
}

function WorkflowFlowWithProvider({
  steps,
  onStepEdit,
  onStepDelete,
  onAddStepClick, // Use updated prop name
  className = '',
}: WorkflowFlowProps) {
  return (
    <ReactFlowProvider>
      <WorkflowFlowContent
        steps={steps}
        onStepEdit={onStepEdit}
        onStepDelete={onStepDelete}
        onAddStepClick={onAddStepClick} // Pass down updated prop
        className={className}
      />
    </ReactFlowProvider>
  );
}

function WorkflowFlowContent({
  steps,
  onStepEdit,
  onStepDelete,
  onAddStepClick, // Use updated prop name
  className = '',
}: WorkflowFlowProps) {
  const reactFlowInstance = useReactFlow();
  
  // Debug log to see if we're getting steps
  console.log('WorkflowFlow received steps:', steps);
  
  // Prepare step data for flow nodes/edges, adding callbacks for editing/deleting
  const preparedSteps = useMemo(() => {
    const prepared = steps.map((step, index) => ({
      ...step,
      onEdit: () => onStepEdit(index),
      onDelete: () => onStepDelete(index),
    }));
    console.log('Prepared steps for React Flow:', prepared);
    return prepared;
  }, [steps, onStepEdit, onStepDelete]);
  
  // Generate nodes and edges from the steps
  const { nodes: initialNodes, edges: initialEdges } = useMemo(() => {
    // Pass onAddStepClick to the transformer function
    const result = stepsToNodesAndEdges(preparedSteps, onAddStepClick); 
    console.log('Transformed to nodes/edges:', result);
    return result;
  }, [preparedSteps, onAddStepClick]); // Add onAddStepClick dependency
  
  // State for nodes and edges
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
  
  // Update nodes and edges when steps change
  useEffect(() => {
    // Regenerate nodes/edges, passing the callback
    const { nodes: newNodes, edges: newEdges } = stepsToNodesAndEdges(preparedSteps, onAddStepClick); 
    console.log('Updating nodes/edges in effect:', { newNodes, newEdges });
    setNodes(newNodes);
    setEdges(newEdges);
    
    // Fit the view to show all nodes
    setTimeout(() => {
      reactFlowInstance.fitView({ padding: 0.2 });
    }, 50);
  }, [preparedSteps, setNodes, setEdges, reactFlowInstance, onAddStepClick]); // Add onAddStepClick dependency
  
  // Node click handler (could be used for selection)
  const onNodeClick: NodeMouseHandler = useCallback((event, node) => {
    console.log('Node clicked:', node);
  }, []);

  // Ref to store connection start data
  const connectingNodeId = useRef<string | null>(null);
  // Removed connection start/end logic for drag-to-add
  // const connectingNodeId = useRef<string | null>(null);
  // const connectingHandleId = useRef<string | null>(null);
  // const onConnectStart = useCallback(...) // Removed
  // const onConnectEnd = useCallback(...) // Removed

  // Handle valid connections (optional, can be used for connecting existing nodes)
  // We might still want this if manual connections are ever allowed, but for now,
  // it doesn't do much as edges are generated by stepsToNodesAndEdges.
  const onConnect = useCallback(
    (params: Connection) => {
      console.log('Connection attempt (should not add edge automatically):', params);
      // setEdges((eds) => addEdge(params, eds)); // Don't automatically add edges
    },
    [setEdges] // Keep dependency if setEdges is used later
  );
  
  return (
    // Use the CSS module class for the wrapper
    <div className={`${styles.reactFlowWrapper} ${className}`}>
      {/* Conditionally render based on initial steps length might be better,
          or always render ReactFlow and let stepsToNodesAndEdges handle the trigger + add edge */}
      {/* Let's always render ReactFlow */}
      {/* {steps.length > 0 ? ( */}
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes} // Use the direct import now
          onNodeClick={onNodeClick}
          // onConnectStart={onConnectStart} // Removed
          // onConnectEnd={onConnectEnd}     // Removed
          onConnect={onConnect}           // Keep for potential future use
          fitView
          fitViewOptions={{ padding: 0.2 }}
          minZoom={0.5}
          maxZoom={1.5}
          defaultViewport={{ x: 0, y: 0, zoom: 1 }}
          connectionLineType={ConnectionLineType.Bezier}
          // Default edge options should now use the type that maps to AddStepEdge
          defaultEdgeOptions={{
            // Keep default type as 'step-edge' for normal connections
            type: 'step-edge',
            style: { strokeWidth: 1.5 },
            markerEnd: {
              type: MarkerType.ArrowClosed,
              width: 15,
              height: 15,
              color: '#94a3b8',
            },
          }}
          // Add an explicit style for the container
          style={{ width: '100%', height: '100%' }}
          className={styles.reactFlow}
        >
          <Background variant={BackgroundVariant.Dots} gap={16} size={1} color="#e2e8f0" />
          <Controls showInteractive={false} position="bottom-right" />
        </ReactFlow>
      {/* ) : (
        // This placeholder might not be needed if Trigger + AddEdge always show
        <div className="flex items-center justify-center h-full bg-gray-50 text-gray-500">
          Workflow is empty. Click the '+' below the trigger to add the first step.
        </div>
      )} */}
    </div>
  );
}

export default WorkflowFlowWithProvider;
